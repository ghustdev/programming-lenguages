Java

PARADIGMA: multiparadigma, mas fortemente orientado a objetos.

Suporta orienta√ß√£o a objetos (quase tudo gira em torno de classes e objetos).

Suporta tamb√©m paradigma procedural (m√©todos est√°ticos, por exemplo o main).

A partir do Java 8, ganhou recursos funcionais (express√µes lambda, streams).

Gen√©rico: possui generics (par√¢metros de tipo), embora de forma menos flex√≠vel que os templates do C++.

TIPA√á√ÉO: forte e est√°tica.

Forte ‚Üí n√£o permite opera√ß√µes impl√≠citas inseguras entre tipos.

Est√°tica ‚Üí os tipos s√£o verificados em tempo de compila√ß√£o e n√£o podem mudar em tempo de execu√ß√£o.

Possui generics com type erasure, ou seja, a informa√ß√£o gen√©rica √© perdida em tempo de execu√ß√£o.

GERENCIAMENTO DE MEM√ìRIA: autom√°tico com Garbage Collector.

Diferente do C++, o programador n√£o precisa desalocar mem√≥ria manualmente (delete, free).

O Garbage Collector detecta objetos que n√£o est√£o mais sendo usados e libera a mem√≥ria.

Por√©m, o programador ainda pode causar vazamentos l√≥gicos de mem√≥ria se mantiver refer√™ncias desnecess√°rias.

--------------------------------------

üîπ 1. Paradigma multiparadigma
a) Orientado a objetos
class Animal {
    void fazerSom() {
        System.out.println("Algum som de animal...");
    }
}

class Cachorro extends Animal {
    @Override
    void fazerSom() {
        System.out.println("Au au!");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal a = new Cachorro(); // polimorfismo
        a.fazerSom();              // sa√≠da: Au au!
    }
}

b) Procedural (uso de m√©todos est√°ticos)
public class Main {
    public static void main(String[] args) {
        int resultado = soma(3, 5); 
        System.out.println(resultado); // sa√≠da: 8
    }

    static int soma(int a, int b) {
        return a + b;
    }
}

c) Funcional (lambda + streams, Java 8+)
import java.util.Arrays;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<Integer> nums = Arrays.asList(1, 2, 3, 4, 5);

        // soma dos pares usando lambda + stream
        int soma = nums.stream()
                       .filter(n -> n % 2 == 0)
                       .mapToInt(n -> n)
                       .sum();

        System.out.println(soma); // sa√≠da: 6 (2 + 4)
    }
}

d) Gen√©rico (Generics)
class Caixa<T> {  // classe gen√©rica
    private T valor;

    public void guardar(T v) { valor = v; }
    public T abrir() { return valor; }
}

public class Main {
    public static void main(String[] args) {
        Caixa<String> c1 = new Caixa<>();
        c1.guardar("Ol√°");
        System.out.println(c1.abrir()); // sa√≠da: Ol√°

        Caixa<Integer> c2 = new Caixa<>();
        c2.guardar(123);
        System.out.println(c2.abrir()); // sa√≠da: 123
    }
}

üîπ 2. Tipagem forte e est√°tica
public class Main {
    public static void main(String[] args) {
        int x = 10;
        // x = "texto"; // ERRO de compila√ß√£o: tipos incompat√≠veis

        double y = 2.5;
        int z = (int) y; // convers√£o expl√≠cita
        System.out.println(z); // sa√≠da: 2
    }
}


üëâ O compilador j√° impede usos incorretos, diferente de linguagens de tipagem fraca.

üîπ 3. Gerenciamento de mem√≥ria autom√°tico
public class Main {
    public static void main(String[] args) {
        String texto = new String("Ol√° mundo");

        // Depois que "texto" n√£o for mais usado, 
        // o Garbage Collector pode liberar essa mem√≥ria automaticamente.
        texto = null; // objeto fica "sem dono"
        
        // For√ßar o GC (n√£o √© garantido que rode agora)
        System.gc();
    }
}


üëâ Diferente do C++, n√£o existe delete ou free. O Garbage Collector cuida disso.